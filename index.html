<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt Generator for App Store Updates</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-50 min-h-screen py-8 px-4">
    <div class="max-w-4xl mx-auto">
        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-800 mb-2">–†–ï–õ–ò–ó –ú–ê–®–ò–ù–ê</h1>
            <p class="text-gray-600">–¥–ª—è App Store Connect MCP-—Å–µ—Ä–≤–µ—Ä–∞</p>
            
            <!-- Step Indicator -->
            <div class="flex justify-center items-center mt-6 space-x-4">
                <div id="step1Indicator" class="flex items-center">
                    <div class="w-10 h-10 rounded-full bg-blue-600 text-white flex items-center justify-center font-bold">1</div>
                    <span class="ml-2 text-sm font-medium text-gray-700">–°–æ–∑–¥–∞–Ω–∏–µ –≤–µ—Ä—Å–∏–∏</span>
                </div>
                <div class="w-8 h-0.5 bg-gray-300"></div>
                <div id="step2Indicator" class="flex items-center">
                    <div class="w-10 h-10 rounded-full bg-gray-300 text-gray-600 flex items-center justify-center font-bold">2</div>
                    <span class="ml-2 text-sm font-medium text-gray-500">–ó–∞–≥—Ä—É–∑–∫–∞ —Å–∫—Ä–∏–Ω—à–æ—Ç–æ–≤</span>
                </div>
            </div>
        </header>

        <!-- Step 1: Version Creation Form -->
        <div id="step1Form" class="bg-white rounded-lg shadow-md p-6 mb-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-6">–®–∞–≥ 1: –°–æ–∑–¥–∞–Ω–∏–µ –≤–µ—Ä—Å–∏–∏ –∏ –ª–æ–∫–∞–ª–µ–π</h2>
            <form id="promptForm" onsubmit="event.preventDefault(); generateStep1();">
                <!-- Bundle ID -->
                <div class="mb-6">
                    <label for="bundleId" class="block text-sm font-semibold text-gray-700 mb-2">
                        Bundle ID <span class="text-red-500">*</span>
                    </label>
                    <input 
                        type="text" 
                        id="bundleId" 
                        value="com.juliangomez.argueforgearena"
                        class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition"
                        placeholder="com.example.app"
                        required
                    >
                </div>

                <!-- Gray Locales -->
                <div class="mb-6">
                    <label for="grayLocales" class="block text-sm font-semibold text-gray-700 mb-2">
                        –°–µ—Ä—ã–µ –ª–æ–∫–∞–ª–∏ (–±–µ–∑ –ø–µ—Ä–µ–≤–æ–¥–∞ keywords)
                    </label>
                    <textarea 
                        id="grayLocales" 
                        rows="3"
                        class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition resize-y"
                        placeholder="Italian, German, Spanish (Spain), ..."
                    >Italian, German, Spanish (Spain), Catalan, French (France), Portuguese (Portugal), Dutch</textarea>
                    <p class="text-xs text-gray-500 mt-1">–†–∞–∑–¥–µ–ª—è–π—Ç–µ –∑–∞–ø—è—Ç—ã–º–∏ –∏–ª–∏ –ø–µ—Ä–µ–Ω–æ—Å–∞–º–∏ —Å—Ç—Ä–æ–∫</p>
                </div>

                <!-- White Locales -->
                <div class="mb-6">
                    <label for="whiteLocales" class="block text-sm font-semibold text-gray-700 mb-2">
                        –ë–µ–ª—ã–µ –ª–æ–∫–∞–ª–∏ (—Å –ø–µ—Ä–µ–≤–æ–¥–æ–º keywords)
                    </label>
                    <textarea 
                        id="whiteLocales" 
                        rows="3"
                        class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition resize-y"
                        placeholder="Czech, Swedish, Vietnamese, ..."
                    >Czech, Swedish, Vietnamese, Turkish, Hindi, Korean, Japanese, Thai, Indonesian, Japanese</textarea>
                    <p class="text-xs text-gray-500 mt-1">–†–∞–∑–¥–µ–ª—è–π—Ç–µ –∑–∞–ø—è—Ç—ã–º–∏ –∏–ª–∏ –ø–µ—Ä–µ–Ω–æ—Å–∞–º–∏ —Å—Ç—Ä–æ–∫</p>
                </div>

                <!-- Gray Name (for App Information) -->
                <div class="mb-6">
                    <label for="grayName" class="block text-sm font-semibold text-gray-700 mb-2">
                        Name –¥–ª—è —Å–µ—Ä—ã—Ö –ª–æ–∫–∞–ª–µ–π
                    </label>
                    <input 
                        type="text" 
                        id="grayName" 
                        class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition"
                        placeholder="–ù–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –¥–ª—è —Å–µ—Ä—ã—Ö –ª–æ–∫–∞–ª–µ–π"
                    >
                </div>

                <!-- Gray Subtitle (for App Information) -->
                <div class="mb-6">
                    <label for="graySubtitle" class="block text-sm font-semibold text-gray-700 mb-2">
                        Subtitle –¥–ª—è —Å–µ—Ä—ã—Ö –ª–æ–∫–∞–ª–µ–π
                    </label>
                    <input 
                        type="text" 
                        id="graySubtitle" 
                        class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition"
                        placeholder="–ü–æ–¥–∑–∞–≥–æ–ª–æ–≤–æ–∫ –¥–ª—è —Å–µ—Ä—ã—Ö –ª–æ–∫–∞–ª–µ–π"
                    >
                </div>

                <!-- Generate Button -->
                <button 
                    type="submit"
                    class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-lg transition duration-200 shadow-md hover:shadow-lg"
                >
                    Generate Prompt
                </button>
            </form>
        </div>

        <!-- Step 2: Screenshots Upload Form -->
        <div id="step2Form" class="bg-white rounded-lg shadow-md p-6 mb-6 hidden">
            <h2 class="text-2xl font-bold text-gray-800 mb-6">–®–∞–≥ 2: –ó–∞–≥—Ä—É–∑–∫–∞ —Å–∫—Ä–∏–Ω—à–æ—Ç–æ–≤</h2>
            <form id="screenshotsForm" onsubmit="event.preventDefault(); generateStep2();">
                <!-- Gray Screenshot Count -->
                <div class="mb-6">
                    <label for="grayScreenshotCount" class="block text-sm font-semibold text-gray-700 mb-2">
                        –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–∫—Ä–∏–Ω—à–æ—Ç–æ–≤ (—Å–µ—Ä—ã–µ –º–æ–∫–∞–ø—ã) <span class="text-red-500">*</span>
                    </label>
                    <input 
                        type="number" 
                        id="grayScreenshotCount" 
                        value="6"
                        min="1"
                        max="10"
                        class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition"
                        placeholder="6"
                        required
                    >
                    <p class="text-xs text-gray-500 mt-1">–§–∞–π–ª—ã 1.jpg ‚Ä¶ N.jpg –≤ –ø–∞–ø–∫–µ —Å–µ—Ä—ã—Ö –º–æ–∫–∞–ø–æ–≤</p>
                </div>

                <!-- White Screenshot Count -->
                <div class="mb-6">
                    <label for="whiteScreenshotCount" class="block text-sm font-semibold text-gray-700 mb-2">
                        –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–∫—Ä–∏–Ω—à–æ—Ç–æ–≤ (–±–µ–ª—ã–µ –º–æ–∫–∞–ø—ã) <span class="text-red-500">*</span>
                    </label>
                    <input 
                        type="number" 
                        id="whiteScreenshotCount" 
                        value="6"
                        min="1"
                        max="10"
                        class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition"
                        placeholder="6"
                        required
                    >
                    <p class="text-xs text-gray-500 mt-1">–§–∞–π–ª—ã 1.jpg ‚Ä¶ N.jpg –≤ –ø–∞–ø–∫–µ –±–µ–ª—ã—Ö –º–æ–∫–∞–ø–æ–≤</p>
                </div>

                <!-- Gray Mockups Path -->
                <div class="mb-6">
                    <label for="grayMockupsPath" class="block text-sm font-semibold text-gray-700 mb-2">
                        –°–µ—Ä—ã–µ –º–æ–∫–∞–ø—ã (Gray Theme) <span class="text-red-500">*</span>
                    </label>
                    <input 
                        type="text" 
                        id="grayMockupsPath" 
                        value="/Users/antonkasian/Documents/iGapps/–ú–æ–∫–∞–ø—ã/New mockup/Utilities770/gray"
                        class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition"
                        placeholder="/path/to/gray/mockups"
                        list="grayMockupsPathSuggestions"
                        autocomplete="off"
                        required
                    >
                    <datalist id="grayMockupsPathSuggestions"></datalist>
                    <p class="text-xs text-gray-500 mt-1">–î–ª—è –ª–æ–∫–∞–ª–µ–π: <span id="grayLocalesDisplay" class="font-medium"></span></p>
                </div>

                <!-- White Mockups Path -->
                <div class="mb-6">
                    <label for="whiteMockupsPath" class="block text-sm font-semibold text-gray-700 mb-2">
                        –ë–µ–ª—ã–µ –º–æ–∫–∞–ø—ã (White Theme) <span class="text-red-500">*</span>
                    </label>
                    <input 
                        type="text" 
                        id="whiteMockupsPath" 
                        value="/Users/antonkasian/Documents/iGapps/–ú–æ–∫–∞–ø—ã/New mockup/Utilities770/white"
                        class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition"
                        placeholder="/path/to/white/mockups"
                        list="whiteMockupsPathSuggestions"
                        autocomplete="off"
                        required
                    >
                    <datalist id="whiteMockupsPathSuggestions"></datalist>
                    <p class="text-xs text-gray-500 mt-1">–î–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –ª–æ–∫–∞–ª–µ–π</p>
                </div>

                <!-- Navigation Buttons -->
                <div class="flex space-x-4">
                    <button 
                        type="button"
                        onclick="goToStep(1)"
                        class="flex-1 bg-gray-500 hover:bg-gray-600 text-white font-semibold py-3 px-6 rounded-lg transition duration-200 shadow-md hover:shadow-lg"
                    >
                        ‚Üê Back
                    </button>
                    <button 
                        type="submit"
                        class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-lg transition duration-200 shadow-md hover:shadow-lg"
                    >
                        Generate Prompt
                    </button>
                </div>
            </form>
        </div>

        <!-- Output Section -->
        <div id="outputSection" class="bg-white rounded-lg shadow-md p-6 hidden">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-semibold text-gray-800">–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø—Ä–æ–º–ø—Ç</h2>
                <div class="flex space-x-2">
                    <button 
                        onclick="copyToClipboard()"
                        id="copyBtn"
                        class="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg transition duration-200 shadow-md hover:shadow-lg"
                    >
                        Copy to Clipboard
                    </button>
                    <button 
                        onclick="goToNextStep()"
                        id="nextBtn"
                        class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg transition duration-200 shadow-md hover:shadow-lg hidden"
                    >
                        Next ‚Üí
                    </button>
                </div>
            </div>
            <textarea 
                id="output" 
                rows="20"
                readonly
                class="w-full px-4 py-3 border border-gray-300 rounded-lg bg-gray-50 font-mono text-sm resize-y focus:outline-none"
            ></textarea>
        </div>

        <!-- Error Message -->
        <div id="errorMessage" class="hidden bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg mt-4" role="alert">
            <strong class="font-bold">–û—à–∏–±–∫–∞!</strong>
            <span class="block sm:inline" id="errorText"></span>
        </div>
    </div>

    <script>
        let currentStep = 1;
        let formData = {};

        function processLocales(text) {
            if (!text || text.trim() === '') {
                return '';
            }
            
            // Split by comma or newline, trim each item, filter empty
            const locales = text
                .split(/[,\n]/)
                .map(item => item.trim())
                .filter(item => item.length > 0);
            
            return locales.join(', ');
        }

        function processLocalesList(text) {
            if (!text || text.trim() === '') {
                return [];
            }
            
            return text
                .split(/[,\n]/)
                .map(item => item.trim())
                .filter(item => item.length > 0);
        }

        function goToStep(step) {
            currentStep = step;
            
            // Hide all forms
            document.getElementById('step1Form').classList.add('hidden');
            document.getElementById('step2Form').classList.add('hidden');
            document.getElementById('outputSection').classList.add('hidden');
            
            // Update step indicators
            const step1Indicator = document.getElementById('step1Indicator');
            const step2Indicator = document.getElementById('step2Indicator');
            
            if (step === 1) {
                step1Indicator.querySelector('div').className = 'w-10 h-10 rounded-full bg-blue-600 text-white flex items-center justify-center font-bold';
                step1Indicator.querySelector('span').className = 'ml-2 text-sm font-medium text-gray-700';
                step2Indicator.querySelector('div').className = 'w-10 h-10 rounded-full bg-gray-300 text-gray-600 flex items-center justify-center font-bold';
                step2Indicator.querySelector('span').className = 'ml-2 text-sm font-medium text-gray-500';
                document.getElementById('step1Form').classList.remove('hidden');
            } else if (step === 2) {
                step1Indicator.querySelector('div').className = 'w-10 h-10 rounded-full bg-green-600 text-white flex items-center justify-center font-bold';
                step1Indicator.querySelector('span').className = 'ml-2 text-sm font-medium text-gray-700';
                step2Indicator.querySelector('div').className = 'w-10 h-10 rounded-full bg-blue-600 text-white flex items-center justify-center font-bold';
                step2Indicator.querySelector('span').className = 'ml-2 text-sm font-medium text-gray-700';
                document.getElementById('step2Form').classList.remove('hidden');
                
                // Update gray locales display
                const grayLocales = processLocales(formData.grayLocales || '');
                document.getElementById('grayLocalesDisplay').textContent = grayLocales || '–Ω–µ —É–∫–∞–∑–∞–Ω—ã';
            }
            
            // Scroll to top
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function goToNextStep() {
            if (currentStep === 1) {
                goToStep(2);
            }
        }

        function generateStep1() {
            // Hide error message
            document.getElementById('errorMessage').classList.add('hidden');
            
            // Get values
            const bundleId = document.getElementById('bundleId').value.trim();
            const grayLocalesRaw = document.getElementById('grayLocales').value;
            const whiteLocalesRaw = document.getElementById('whiteLocales').value;
            const grayName = document.getElementById('grayName').value.trim();
            const graySubtitle = document.getElementById('graySubtitle').value.trim();
            
            // Validate Bundle ID
            if (!bundleId) {
                showError('Bundle ID –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è!');
                return;
            }
            
            // Save form data
            formData.bundleId = bundleId;
            formData.grayLocales = grayLocalesRaw;
            formData.whiteLocales = whiteLocalesRaw;
            formData.grayName = grayName;
            formData.graySubtitle = graySubtitle;
            
            // Process locales
            const grayLocales = processLocales(grayLocalesRaw);
            const whiteLocales = processLocales(whiteLocalesRaw);
            
            // Build the prompt
            let prompt = `–£ –º–µ–Ω—è –Ω–∞—Å—Ç—Ä–æ–µ–Ω –∏ —Ä–∞–±–æ—Ç–∞–µ—Ç App Store Connect MCP-—Å–µ—Ä–≤–µ—Ä (asc-mcp), —Å—Ç–∞—Ç—É—Å –∑–µ–ª—ë–Ω—ã–π, –≤—Å–µ –∫–ª—é—á–∏ (ASC_KEY_ID, ASC_ISSUER_ID, ASC_PRIVATE_KEY) –∑–∞–ø–æ–ª–Ω–µ–Ω—ã –ø—Ä–∞–≤–∏–ª—å–Ω–æ.
–ú–Ω–µ –Ω—É–∂–Ω–æ –≤–Ω–µ—Å—Ç–∏ —Å–ª–µ–¥—É—é—â–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ App Store Connect –¥–ª—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è (bundle ID: ${bundleId} ‚Äî —É—Ç–æ—á–Ω–∏ —É –º–µ–Ω—è –µ—Å–ª–∏ –Ω—É–∂–Ω–æ).
–í—ã–ø–æ–ª–Ω—è–π –í–°–ï –¥–µ–π—Å—Ç–≤–∏—è –¢–û–õ–¨–ö–û —á–µ—Ä–µ–∑ App Store Connect MCP-—Å–µ—Ä–≤–µ—Ä, —à–∞–≥ –∑–∞ —à–∞–≥–æ–º, –Ω–µ –ø—Ä–∏–¥—É–º—ã–≤–∞–π –∫–æ–º–∞–Ω–¥—ã –≤—Ä—É—á–Ω—É—é. –ü–æ—Å–ª–µ –∫–∞–∂–¥–æ–≥–æ –≤–∞–∂–Ω–æ–≥–æ —à–∞–≥–∞ –ø–æ–∫–∞–∑—ã–≤–∞–π, —á—Ç–æ –ø–æ–ª—É—á–∏–ª–æ—Å—å (–æ—Ç–≤–µ—Ç —Å–µ—Ä–≤–µ—Ä–∞).
–ó–∞–¥–∞—á–∞ —Ä–∞–∑–±–∏—Ç–∞ –Ω–∞ —ç—Ç–∞–ø—ã ‚Äî –≤—ã–ø–æ–ª–Ω—è–π —Å—Ç—Ä–æ–≥–æ –ø–æ –ø–æ—Ä—è–¥–∫—É:

–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –≤–µ—Ä—Å–∏—é –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è ‚Äî –≤–µ—Ä—Å–∏—è 1.1 (build number –æ—Å—Ç–∞–≤—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –∏–ª–∏ —Å–ª–µ–¥—É—é—â–∏–π –¥–æ—Å—Ç—É–ø–Ω—ã–π)
–í —Ä–∞–∑–¥–µ–ª–µ "What's New in This Version" (–¥–ª—è –≤–µ—Ä—Å–∏–∏ 1.1) –¥–æ–±–∞–≤–∏—Ç—å —Ç–µ–∫—Å—Ç (–Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–æ–º, –ø–æ—Ç–æ–º –ø–µ—Ä–µ–≤–µ–¥—ë–º):
"Minor update
‚Ä¢ Bug fixes and stability improvements
‚Ä¢ Small performance optimizations
‚Ä¢ Minor UI tweaks and fixes
‚Ä¢ General improvements for a smoother experience"
–ü–æ–¥—á–µ—Ä–∫–Ω–∏, —á—Ç–æ —ç—Ç–æ –º–∏–Ω–æ—Ä–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ, —Å–æ—Å—Ä–µ–¥–æ—Ç–æ—á–µ–Ω–Ω–æ–µ –Ω–∞ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ –æ—à–∏–±–æ–∫ –∏ –Ω–µ–±–æ–ª—å—à–∏—Ö —É–ª—É—á—à–µ–Ω–∏—è—Ö.
–í App Information ‚Üí Marketing URL: —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ –ø–æ–ª—è "Support URL" / "Contact form URL" (–ø—Ä–æ–¥—É–±–ª–∏—Ä–æ–≤–∞—Ç—å –æ–¥–Ω—É –∏ —Ç—É –∂–µ —Å—Å—ã–ª–∫—É –≤ –æ–±–∞ –ø–æ–ª—è)
–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤—Å–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –Ω–∞ —ç—Ç–æ–º —ç—Ç–∞–ø–µ (submit version changes)
–î–æ–±–∞–≤–∏—Ç—å —Å–ª–µ–¥—É—é—â–∏–µ –Ω–æ–≤—ã–µ –ª–æ–∫–∞–ª–∏ (–µ—Å–ª–∏ –∏—Ö –µ—â—ë –Ω–µ—Ç):`;

            // Add gray locales if present
            if (grayLocales) {
                prompt += `\n${grayLocales}`;
            }
            
            // Add white locales if present
            if (whiteLocales) {
                if (grayLocales) {
                    prompt += `, ${whiteLocales}`;
                } else {
                    prompt += `\n${whiteLocales}`;
                }
            }

            prompt += `
–î–ª—è –∫–∞–∂–¥–æ–π –Ω–æ–≤–æ–π –ª–æ–∫–∞–ª–∏ —Å—Ä–∞–∑—É:
–ü–µ—Ä–µ–≤–µ—Å—Ç–∏ –∏ –∑–∞–ø–æ–ª–Ω–∏—Ç—å –æ–ø–∏—Å–∞–Ω–∏–µ (description) –Ω–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π —è–∑—ã–∫ –ª–æ–∫–∞–ª–∏
–ü–µ—Ä–µ–≤–µ—Å—Ç–∏ –∏ –∑–∞–ø–æ–ª–Ω–∏—Ç—å keywords –Ω–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π —è–∑—ã–∫ –ª–æ–∫–∞–ª–∏ (–ò—Å–ø–æ–ª—å–∑—É–π 3 keywords)`;

            // Add "–ù–ï –ø–µ—Ä–µ–≤–æ–¥–∏ keywords" only if gray locales exist
            if (grayLocales) {
                prompt += `
–ù–ï –ø–µ—Ä–µ–≤–æ–¥–∏ keywords –Ω–∞ –ª–æ–∫–∞–ª—è—Ö: ${grayLocales}`;
            }

            prompt += `

–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–æ—Å–ª–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è –≤—Å–µ—Ö –Ω–æ–≤—ã—Ö –ª–æ–∫–∞–ª–µ–π.`;

            // App Information: Name and Subtitle
            prompt += `

–í–∫–ª–∞–¥–∫–∞ App Information ‚Äî Name –∏ Subtitle:
- –î–ª—è –≤—Å–µ—Ö **–±–µ–ª—ã—Ö** –ª–æ–∫–∞–ª–µ–π: –ø–æ–ª–µ Name –∏–∑–º–µ–Ω–∏—Ç—å –Ω–∞ **–ø–µ—Ä–µ–≤–µ–¥—ë–Ω–Ω–æ–µ —Ç–µ–∫—É—â–µ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ**. –¢–µ–∫—É—â–µ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ ‚Äî —Ç–æ, —á—Ç–æ —É–∫–∞–∑–∞–Ω–æ –≤ –ª–æ–∫–∞–ª–∏ US (English). –ü–µ—Ä–µ–≤–µ–¥–∏ –µ–≥–æ –Ω–∞ —è–∑—ã–∫ –∫–∞–∂–¥–æ–π –±–µ–ª–æ–π –ª–æ–∫–∞–ª–∏ –∏ –≤—Å—Ç–∞–≤—å –≤ Name –¥–ª—è —ç—Ç–æ–π –ª–æ–∫–∞–ª–∏.
- –î–ª—è –≤—Å–µ—Ö **—Å–µ—Ä—ã—Ö** –ª–æ–∫–∞–ª–µ–π:`;
            if (grayName && graySubtitle) {
                prompt += ` –∑–∞–ø–æ–ª–Ω–∏—Ç—å Name –∏ Subtitle –∑–∞–¥–∞–Ω–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏: Name = "${grayName}". Subtitle = "${graySubtitle}".`;
            } else if (grayName) {
                prompt += ` –∑–∞–ø–æ–ª–Ω–∏—Ç—å Name –∑–∞–¥–∞–Ω–Ω—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º: Name = "${grayName}".`;
            } else if (graySubtitle) {
                prompt += ` –∑–∞–ø–æ–ª–Ω–∏—Ç—å Subtitle –∑–∞–¥–∞–Ω–Ω—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º: Subtitle = "${graySubtitle}".`;
            } else {
                prompt += ` –∑–Ω–∞—á–µ–Ω–∏—è Name –∏ Subtitle —É—Ç–æ—á–Ω–∏ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.`;
            }

            prompt += `

–ü–æ—Å–ª–µ –≤—Å–µ—Ö –∏–∑–º–µ–Ω–µ–Ω–∏–π:
–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤—Å—ë
–ü–æ–∫–∞–∑–∞—Ç—å –º–Ω–µ —Ñ–∏–Ω–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –≤–µ—Ä—Å–∏–∏ 1.1 (–∫–∞–∫–∏–µ –ª–æ–∫–∞–ª–∏ –¥–æ–±–∞–≤–ª–µ–Ω—ã, –∫–∞–∫–∏–µ —Ç–∞–π—Ç–ª—ã/—Å–∞–±—Ç–∞–π—Ç–ª—ã –∏–∑–º–µ–Ω–µ–Ω—ã, —á—Ç–æ –≤ What's New)
–ï—Å–ª–∏ –ø–æ—Ç—Ä–µ–±—É–µ—Ç—Å—è ‚Äî –ø–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å –≤–µ—Ä—Å–∏—é –∫ –æ—Ç–ø—Ä–∞–≤–∫–µ –Ω–∞ review (–Ω–æ –ù–ï –æ—Ç–ø—Ä–∞–≤–ª—è–π –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏, —Ç–æ–ª—å–∫–æ –ø–æ–¥–≥–æ—Ç–æ–≤—å)
–î–µ–π—Å—Ç–≤—É–π —Å—Ç—Ä–æ–≥–æ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ, —à–∞–≥ –∑–∞ —à–∞–≥–æ–º.
–ü–æ—Å–ª–µ –∫–∞–∂–¥–æ–≥–æ –∫—Ä—É–ø–Ω–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è (—Å–æ–∑–¥–∞–Ω–∏–µ –≤–µ—Ä—Å–∏–∏, –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –ª–æ–∫–∞–ª–µ–π, –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Ç–∞–π—Ç–ª–æ–≤ –∏ —Ç.–¥.) –ø–æ–∫–∞–∑—ã–≤–∞–π –æ—Ç–≤–µ—Ç –æ—Ç MCP-—Å–µ—Ä–≤–µ—Ä–∞ –∏–ª–∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ.
–ï—Å–ª–∏ –≥–¥–µ-—Ç–æ –Ω—É–∂–Ω–∞ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ—Ç –º–µ–Ω—è (bundle ID, —Ç–µ–∫—É—â–∏–π app ID –≤ App Store Connect, —Ç–æ—á–Ω—ã–π —Ç–µ–∫—Å—Ç –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞ –∏ —Ç.–¥.) ‚Äî —Å–ø—Ä–æ—Å–∏.
–ù–∞—á–∏–Ω–∞–π —Å —à–∞–≥–∞ 1 ‚Äî —Å–æ–∑–¥–∞–Ω–∏–µ –≤–µ—Ä—Å–∏–∏ 1.1`;

            // Display output
            document.getElementById('output').value = prompt;
            document.getElementById('outputSection').classList.remove('hidden');
            document.getElementById('nextBtn').classList.remove('hidden');
            
            // Scroll to output
            document.getElementById('outputSection').scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function generateStep2() {
            // Hide error message
            document.getElementById('errorMessage').classList.add('hidden');
            
            // Get values
            const grayScreenshotCount = document.getElementById('grayScreenshotCount').value.trim();
            const whiteScreenshotCount = document.getElementById('whiteScreenshotCount').value.trim();
            const grayPath = document.getElementById('grayMockupsPath').value.trim();
            const whitePath = document.getElementById('whiteMockupsPath').value.trim();
            
            // Validate
            if (!grayScreenshotCount || !whiteScreenshotCount || !grayPath || !whitePath) {
                showError('–í—Å–µ –ø–æ–ª—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è!');
                return;
            }
            
            // Process locales
            const grayLocales = processLocales(formData.grayLocales || '');
            const grayLocalesList = processLocalesList(formData.grayLocales || '');
            
            // Build the prompt
            let prompt = `–£ –º–µ–Ω—è –Ω–∞—Å—Ç—Ä–æ–µ–Ω –∏ —Ä–∞–±–æ—Ç–∞–µ—Ç App Store Connect MCP-—Å–µ—Ä–≤–µ—Ä (asc-mcp), —Å—Ç–∞—Ç—É—Å –∑–µ–ª—ë–Ω—ã–π.

–°–µ–π—á–∞—Å —è —Ö–æ—á—É –ø–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞–º–µ–Ω–∏—Ç—å –≤—Å–µ —Å–∫—Ä–∏–Ω—à–æ—Ç—ã (mockups / screenshots) –≤ –≤–µ—Ä—Å–∏–∏ 1.1 –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è —Ç–æ–ª—å–∫–æ –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω—ã—Ö –ª–æ–∫–∞–ª–µ–π.

–ó–∞–≥—Ä—É–∂–∞–π —Å–∫—Ä–∏–Ω—à–æ—Ç—ã **—Å—Ç—Ä–æ–≥–æ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ –ø–æ –Ω–æ–º–µ—Ä–∞–º**. –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ª–æ—Ç–æ–≤ —Ä–∞–∑–Ω–æ–µ –¥–ª—è —Å–µ—Ä—ã—Ö –∏ –±–µ–ª—ã—Ö –ª–æ–∫–∞–ª–µ–π.

–†–∞–∑–¥–µ–ª–∏—Ç—å –ø–æ –≥—Ä—É–ø–ø–∞–º –ª–æ–∫–∞–ª–µ–π:
`;

            // Add gray locales group
            if (grayLocales) {
                prompt += `
–ì—Ä—É–ø–ø–∞ 1 (—Å–µ—Ä—ã–µ –º–æ–∫–∞–ø—ã / gray theme):`;
                grayLocalesList.forEach(locale => {
                    prompt += `\n${locale}`;
                });
                
                prompt += `

–î–ª—è —ç—Ç–∏—Ö –ª–æ–∫–∞–ª–µ–π –∑–∞–≥—Ä—É–∂–∞—Ç—å —Å–∫—Ä–∏–Ω—à–æ—Ç—ã –∏–∑ –ø–∞–ø–∫–∏:
"${grayPath}"
–°–∫—Ä–∏–Ω—à–æ—Ç—ã –ø—Ä–æ–Ω—É–º–µ—Ä–æ–≤–∞–Ω—ã –æ—Ç 1 –¥–æ ${grayScreenshotCount} (—Ñ–∞–π–ª—ã 1.jpg‚Äì${grayScreenshotCount}.jpg). –ó–∞–≥—Ä—É–∂–∞–π —Å—Ç—Ä–æ–≥–æ –ø–æ –Ω–æ–º–µ—Ä–∞–º: —Å–∫—Ä–∏–Ω—à–æ—Ç 1 ‚Üí –ø–µ—Ä–≤—ã–π —Å–ª–æ—Ç, —Å–∫—Ä–∏–Ω—à–æ—Ç 2 ‚Üí –≤—Ç–æ—Ä–æ–π —Å–ª–æ—Ç –∏ —Ç.–¥. –¥–æ ${grayScreenshotCount}-–≥–æ —Å–ª–æ—Ç–∞.
`;
            }

            prompt += `
–ì—Ä—É–ø–ø–∞ 2 (–±–µ–ª—ã–µ –º–æ–∫–∞–ø—ã / white theme):
–î–ª—è –≤—Å–µ—Ö –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –ª–æ–∫–∞–ª–µ–π

–î–ª—è —ç—Ç–∏—Ö –ª–æ–∫–∞–ª–µ–π –∑–∞–≥—Ä—É–∂–∞—Ç—å —Å–∫—Ä–∏–Ω—à–æ—Ç—ã –∏–∑ –ø–∞–ø–∫–∏:
"${whitePath}"
–°–∫—Ä–∏–Ω—à–æ—Ç—ã –ø—Ä–æ–Ω—É–º–µ—Ä–æ–≤–∞–Ω—ã –æ—Ç 1 –¥–æ ${whiteScreenshotCount} (—Ñ–∞–π–ª—ã 1.jpg‚Äì${whiteScreenshotCount}.jpg). –ó–∞–≥—Ä—É–∂–∞–π —Å—Ç—Ä–æ–≥–æ –ø–æ –Ω–æ–º–µ—Ä–∞–º: —Å–∫—Ä–∏–Ω—à–æ—Ç 1 ‚Üí –ø–µ—Ä–≤—ã–π —Å–ª–æ—Ç, —Å–∫—Ä–∏–Ω—à–æ—Ç 2 ‚Üí –≤—Ç–æ—Ä–æ–π —Å–ª–æ—Ç –∏ —Ç.–¥. –¥–æ ${whiteScreenshotCount}-–≥–æ —Å–ª–æ—Ç–∞.

–ù–µ –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–π –ø–æ—Ä—è–¥–æ–∫, –Ω–µ –≤—ã–±–∏—Ä–∞–π —Å–ª—É—á–∞–π–Ω—ã–µ —Ñ–∞–π–ª—ã ‚Äî —Å—Ç—Ä–æ–≥–æ –ø–æ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—é –Ω–æ–º–µ—Ä–∞.

–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –∫ –∑–∞–≥—Ä—É–∑–∫–µ:
- –ó–∞–≥—Ä—É–∂–∞—Ç—å —Å–∫—Ä–∏–Ω—à–æ—Ç—ã –¥–ª—è 6.5"
- –ü–æ—Å–ª–µ –∑–∞–º–µ–Ω—ã —Å–∫—Ä–∏–Ω—à–æ—Ç–æ–≤ –ù–ï –º–µ–Ω—è–π –¥—Ä—É–≥–∏–µ –ø–æ–ª—è (description, keywords, title, subtitle –∏ —Ç.–¥.) ‚Äî —Ç–æ–ª—å–∫–æ —Å–∫—Ä–∏–Ω—à–æ—Ç—ã

–î–µ–π—Å—Ç–≤—É–π —à–∞–≥ –∑–∞ —à–∞–≥–æ–º:
1. –°–Ω–∞—á–∞–ª–∞ –ø–æ–∫–∞–∂–∏ –º–Ω–µ —Å–ø–∏—Å–æ–∫ —Ç–µ–∫—É—â–∏—Ö —Å–∫—Ä–∏–Ω—à–æ—Ç–æ–≤ –≤ –≤–µ—Ä—Å–∏–∏ 1.1 –¥–ª—è —ç—Ç–∏—Ö –ª–æ–∫–∞–ª–µ–π (—á—Ç–æ–±—ã —è —É–≤–∏–¥–µ–ª, —á—Ç–æ –±—É–¥–µ—Ç –∑–∞–º–µ–Ω–µ–Ω–æ)
2. –ó–∞–≥—Ä—É–∑–∏ –Ω–æ–≤—ã–µ —Å–∫—Ä–∏–Ω—à–æ—Ç—ã –∏–∑ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏—Ö –ø–∞–ø–æ–∫: –¥–ª—è —Å–µ—Ä—ã—Ö –ª–æ–∫–∞–ª–µ–π ‚Äî —Å—Ç—Ä–æ–≥–æ –ø–æ –Ω–æ–º–µ—Ä–∞–º 1‚Äì${grayScreenshotCount}, –¥–ª—è –±–µ–ª—ã—Ö –ª–æ–∫–∞–ª–µ–π ‚Äî —Å—Ç—Ä–æ–≥–æ –ø–æ –Ω–æ–º–µ—Ä–∞–º 1‚Äì${whiteScreenshotCount}
3. –ü–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏ —É—Å–ø–µ—Ö: —Å–∫–æ–ª—å–∫–æ —Å–∫—Ä–∏–Ω—à–æ—Ç–æ–≤ –∑–∞–≥—Ä—É–∂–µ–Ω–æ –¥–ª—è —Å–µ—Ä—ã—Ö –ª–æ–∫–∞–ª–µ–π (1‚Äì${grayScreenshotCount}), —Å–∫–æ–ª—å–∫–æ –¥–ª—è –±–µ–ª—ã—Ö (1‚Äì${whiteScreenshotCount}), –¥–ª—è –∫–∞–∫–∏—Ö –ª–æ–∫–∞–ª–µ–π –∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤

–ï—Å–ª–∏ Cursor –Ω–µ –º–æ–∂–µ—Ç —á–∏—Ç–∞—Ç—å –ª–æ–∫–∞–ª—å–Ω—ã–µ —Ñ–∞–π–ª—ã –Ω–∞–ø—Ä—è–º—É—é ‚Äî –ø–æ–ø—Ä–æ—Å–∏ –º–µ–Ω—è –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–∫—Ä–∏–Ω—à–æ—Ç—ã –≤ —á–∞—Ç –∏–ª–∏ –¥–∞—Ç—å –ø—É–±–ª–∏—á–Ω—ã–µ URL –Ω–∞ –Ω–∏—Ö.

–ï—Å–ª–∏ –Ω—É–∂–Ω–æ —É—Ç–æ—á–Ω–∏—Ç—å bundle ID –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è, app ID –≤ App Store Connect, —Ç–æ—á–Ω—ã–µ –∏–º–µ–Ω–∞ —Ñ–∞–π–ª–æ–≤ –∏–ª–∏ –∫–∞–∫ –∏–º–µ–Ω–Ω–æ –Ω–∞–∑–≤–∞–Ω—ã —Å–∫—Ä–∏–Ω—à–æ—Ç—ã –≤ –ø–∞–ø–∫–∞—Ö ‚Äî —Å–ø—Ä–æ—Å–∏ –º–µ–Ω—è.

–ù–∞—á–∏–Ω–∞–π —Å —à–∞–≥–∞ 1 ‚Äî –ø–æ–∫–∞–∂–∏ —Ç–µ–∫—É—â–∏–µ —Å–∫—Ä–∏–Ω—à–æ—Ç—ã –≤ –≤–µ—Ä—Å–∏–∏ 1.1 –¥–ª—è –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–Ω—ã—Ö –ª–æ–∫–∞–ª–µ–π.`;

            // Display output
            document.getElementById('output').value = prompt;
            document.getElementById('outputSection').classList.remove('hidden');
            document.getElementById('nextBtn').classList.add('hidden');
            
            // Scroll to output
            document.getElementById('outputSection').scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function copyToClipboard() {
            const output = document.getElementById('output');
            const copyBtn = document.getElementById('copyBtn');
            
            // Copy to clipboard
            output.select();
            document.execCommand('copy');
            
            // Visual feedback
            const originalText = copyBtn.textContent;
            copyBtn.textContent = 'Copied!';
            copyBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
            copyBtn.classList.add('bg-green-800');
            
            setTimeout(() => {
                copyBtn.textContent = originalText;
                copyBtn.classList.remove('bg-green-800');
                copyBtn.classList.add('bg-green-600', 'hover:bg-green-700');
            }, 2000);
        }

        function showError(message) {
            const errorMessage = document.getElementById('errorMessage');
            const errorText = document.getElementById('errorText');
            
            errorText.textContent = message;
            errorMessage.classList.remove('hidden');
            
            // Scroll to error
            errorMessage.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        // Build file tree structure from files
        function buildFileTree(files) {
            const tree = {};
            let rootPath = '';

            // Process all files to build tree structure
            for (let file of files) {
                if (file.webkitRelativePath) {
                    const parts = file.webkitRelativePath.split('/');
                    if (!rootPath && parts.length > 0) {
                        rootPath = parts[0]; // First part is usually the root folder name
                    }
                    
                    let current = tree;
                    for (let i = 0; i < parts.length; i++) {
                        const part = parts[i];
                        if (!current[part]) {
                            current[part] = i === parts.length - 1 ? { _file: file } : {};
                        }
                        current = current[part];
                    }
                }
            }

            return { tree, rootPath };
        }

        // Render file tree with indentation
        function renderFileTree(tree, container, indent = 0) {
            let html = '';

            const sortedKeys = Object.keys(tree).sort((a, b) => {
                const aIsFile = tree[a]._file ? 1 : 0;
                const bIsFile = tree[b]._file ? 1 : 0;
                if (aIsFile !== bIsFile) return aIsFile - bIsFile;
                return a.localeCompare(b);
            });

            for (let key of sortedKeys) {
                if (key === '_file') continue;
                
                const isFile = tree[key]._file ? true : false;
                const icon = isFile ? 'üìÑ' : 'üìÅ';
                const indentPx = indent * 20;
                const isRoot = indent === 0;
                
                html += `<div class="py-0.5 flex items-center ${isRoot ? 'font-semibold text-gray-800' : 'text-gray-600'}" style="padding-left: ${indentPx}px;">
                    <span class="mr-1">${icon}</span>
                    <span>${key}</span>
                </div>`;
                
                if (!isFile) {
                    html += renderFileTree(tree[key], container, indent + 1);
                }
            }

            return html;
        }

        // Get full path from webkitRelativePath - improved version
        function extractFullPath(files) {
            if (!files || files.length === 0) return '';

            const firstFile = files[0];
            
            // Method 1: Use file.path property if available (works when dragging from Finder on Mac)
            if (firstFile.path && firstFile.webkitRelativePath) {
                const fullFilePath = firstFile.path;
                const relativePath = firstFile.webkitRelativePath;
                
                // Remove filename from both paths
                const fullPathWithoutFile = fullFilePath.substring(0, fullFilePath.lastIndexOf('/'));
                const relativePathWithoutFile = relativePath.substring(0, relativePath.lastIndexOf('/'));
                
                // Calculate depth of relative path (how many folders deep)
                const relativeDepth = relativePathWithoutFile.split('/').filter(p => p).length;
                
                // Split full path and go up relativeDepth levels
                const fullPathParts = fullPathWithoutFile.split('/').filter(p => p);
                
                if (fullPathParts.length >= relativeDepth) {
                    const rootPathParts = fullPathParts.slice(0, fullPathParts.length - relativeDepth);
                    return '/' + rootPathParts.join('/');
                }
                
                // Alternative: try to find root folder by name matching
                const rootFolderName = relativePath.split('/')[0];
                const rootIndex = fullPathParts.lastIndexOf(rootFolderName);
                if (rootIndex !== -1) {
                    return '/' + fullPathParts.slice(0, rootIndex + 1).join('/');
                }
            }
            
            // Method 2: Try multiple files to find common base path
            if (files.length > 1) {
                const filesWithPaths = files.filter(f => f.path && f.webkitRelativePath);
                
                if (filesWithPaths.length > 0) {
                    let commonBasePath = null;
                    
                    for (let file of filesWithPaths) {
                        const fullFilePath = file.path;
                        const relativePath = file.webkitRelativePath;
                        
                        // Remove filename
                        const fullPathWithoutFile = fullFilePath.substring(0, fullFilePath.lastIndexOf('/'));
                        const relativePathWithoutFile = relativePath.substring(0, relativePath.lastIndexOf('/'));
                        const relativeDepth = relativePathWithoutFile.split('/').filter(p => p).length;
                        
                        const fullPathParts = fullPathWithoutFile.split('/').filter(p => p);
                        
                        if (fullPathParts.length >= relativeDepth) {
                            const basePath = '/' + fullPathParts.slice(0, fullPathParts.length - relativeDepth).join('/');
                            
                            if (!commonBasePath) {
                                commonBasePath = basePath;
                            } else {
                                // Find longest common prefix
                                const baseParts = commonBasePath.split('/').filter(p => p);
                                const currentParts = basePath.split('/').filter(p => p);
                                const commonParts = [];
                                
                                for (let i = 0; i < Math.min(baseParts.length, currentParts.length); i++) {
                                    if (baseParts[i] === currentParts[i]) {
                                        commonParts.push(baseParts[i]);
                                    } else {
                                        break;
                                    }
                                }
                                
                                if (commonParts.length > 0) {
                                    commonBasePath = '/' + commonParts.join('/');
                                } else {
                                    commonBasePath = '';
                                    break;
                                }
                            }
                        }
                    }
                    
                    if (commonBasePath && commonBasePath.length > 1) {
                        return commonBasePath;
                    }
                }
            }

            return '';
        }

        // Save directory handle to localStorage for future use
        function saveDirectoryHandle(type, directoryHandle) {
            try {
                // We can't serialize directoryHandle directly, but we can save permission
                // The actual handle will be requested again, but browser will remember the permission
                localStorage.setItem(`lastFolder_${type}`, directoryHandle.name);
            } catch (e) {
                console.log('Could not save directory handle:', e);
            }
        }

        // Get saved directory handle name
        function getSavedDirectoryHandle(type) {
            try {
                return localStorage.getItem(`lastFolder_${type}`);
            } catch (e) {
                return null;
            }
        }

        // Select folder using File System Access API - IMPROVED VERSION
        async function selectFolder(type) {
            try {
                if ('showDirectoryPicker' in window) {
                    // Try to use saved directory handle if available
                    let directoryHandle;
                    const savedFolderName = getSavedDirectoryHandle(type);
                    
                    // Request directory picker
                    directoryHandle = await window.showDirectoryPicker({
                        // Optionally start in the last used directory
                        startIn: 'documents' // or 'downloads', 'desktop', etc.
                    });
                    
                    // Save the handle for future reference
                    saveDirectoryHandle(type, directoryHandle);
                    
                    // Get all files from directory recursively
                    const files = [];
                    async function readDirectory(dirHandle, path = '') {
                        for await (const entry of dirHandle.values()) {
                            const entryPath = path ? `${path}/${entry.name}` : entry.name;
                            if (entry.kind === 'file') {
                                const file = await entry.getFile();
                                file.webkitRelativePath = entryPath;
                                // Try to get path if available
                                if (entry.fullPath) {
                                    file.path = entry.fullPath;
                                }
                                files.push(file);
                            } else if (entry.kind === 'directory') {
                                await readDirectory(entry, entryPath);
                            }
                        }
                    }
                    
                    await readDirectory(directoryHandle);
                    
                    // Process files
                    if (files.length > 0) {
                        const inputElement = document.getElementById(`${type}MockupsPath`);
                        const fileTreeElement = document.getElementById(`${type}FileTree`);
                        const dropZoneContent = document.getElementById(`${type}DropZoneContent`);
                        
                        // Build and render tree
                        const { tree } = buildFileTree(files);
                        const treeHtml = renderFileTree(tree, fileTreeElement);
                        fileTreeElement.innerHTML = treeHtml;
                        fileTreeElement.classList.remove('hidden');
                        dropZoneContent.classList.add('hidden');
                        
                        // Try to get full path using multiple methods
                        let fullPathValue = '';
                        
                        // Method 1: Try extractFullPath function
                        fullPathValue = extractFullPath(files);
                        console.log('selectFolder - method 1 (extractFullPath):', fullPathValue);
                        
                        // Method 2: Try to get from file.path property
                        if (!fullPathValue || fullPathValue.length < 3) {
                            for (let file of files) {
                                if (file.path && file.webkitRelativePath) {
                                    const fullFilePath = file.path;
                                    const relativePath = file.webkitRelativePath;
                                    
                                    // Normalize paths
                                    const fullPathNormalized = fullFilePath.replace(/\\/g, '/');
                                    const relativePathNormalized = relativePath.replace(/\\/g, '/');
                                    
                                    // Remove filename from both
                                    const fullDirPath = fullPathNormalized.substring(0, fullPathNormalized.lastIndexOf('/'));
                                    const relativeDirPath = relativePathNormalized.substring(0, relativePathNormalized.lastIndexOf('/'));
                                    
                                    // Calculate depth
                                    const relativeDepth = relativeDirPath.split('/').filter(p => p && p !== '.').length;
                                    const fullDirParts = fullDirPath.split('/').filter(p => p && p !== '.');
                                    
                                    if (fullDirParts.length >= relativeDepth) {
                                        const rootParts = fullDirParts.slice(0, fullDirParts.length - relativeDepth);
                                        fullPathValue = '/' + rootParts.join('/');
                                        console.log('selectFolder - method 2 (file.path):', fullPathValue);
                                        break;
                                    }
                                }
                            }
                        }
                        
                        // Method 3: Try to construct from directory handle name and common paths
                        if (!fullPathValue || fullPathValue.length < 3) {
                            // Try common macOS paths
                            const commonPaths = [
                                '/Users',
                                '/Users/' + (process?.env?.USER || ''),
                                process?.env?.HOME || '',
                                '/Users/' + (navigator.userAgent.includes('Mac') ? 'antonkasian' : '')
                            ].filter(p => p);
                            
                            const folderName = directoryHandle.name;
                            
                            // Try to find folder in common paths
                            for (let basePath of commonPaths) {
                                if (basePath) {
                                    // This is a heuristic - we can't actually check if folder exists
                                    // But we can suggest the most likely path
                                    const suggestedPath = basePath + '/Documents/iGapps/–ú–æ–∫–∞–ø—ã/New mockup';
                                    if (suggestedPath.includes(folderName) || folderName.includes('gray') || folderName.includes('white')) {
                                        // This looks like it might be the right path
                                        fullPathValue = suggestedPath + '/' + folderName;
                                        console.log('selectFolder - method 3 (heuristic):', fullPathValue);
                                        break;
                                    }
                                }
                            }
                        }
                        
                        // If we still don't have a good path, show helpful message
                        if (!fullPathValue || fullPathValue.length < 3) {
                            // Create a more helpful UI
                            const hintContainer = document.createElement('div');
                            hintContainer.className = 'mt-2 p-3 bg-gradient-to-r from-blue-50 to-indigo-50 border border-blue-300 rounded-lg';
                            hintContainer.innerHTML = `
                                <div class="flex items-start">
                                    <div class="flex-shrink-0">
                                        <svg class="h-5 w-5 text-blue-600" fill="currentColor" viewBox="0 0 20 20">
                                            <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"/>
                                        </svg>
                                    </div>
                                    <div class="ml-3 flex-1">
                                        <h3 class="text-sm font-medium text-blue-800">–ü—É—Ç—å –∫ –ø–∞–ø–∫–µ –≤—ã–±—Ä–∞–Ω</h3>
                                        <div class="mt-2 text-sm text-blue-700">
                                            <p>–ü–∞–ø–∫–∞ "<strong>${directoryHandle.name}</strong>" –≤—ã–±—Ä–∞–Ω–∞ —É—Å–ø–µ—à–Ω–æ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –ø–æ–ª–Ω—ã–π –ø—É—Ç—å –∫ —ç—Ç–æ–π –ø–∞–ø–∫–µ –≤ –ø–æ–ª–µ –Ω–∏–∂–µ.</p>
                                            <p class="mt-1 text-xs text-blue-600">üí° –°–æ–≤–µ—Ç: –°–∫–æ–ø–∏—Ä—É–π—Ç–µ –ø—É—Ç—å –∏–∑ Finder (Cmd+Option+C) –∏ –≤—Å—Ç–∞–≤—å—Ç–µ —Å—é–¥–∞.</p>
                                        </div>
                                    </div>
                                </div>
                            `;
                            
                            // Remove any existing hints
                            const existingHints = inputElement.parentElement.querySelectorAll('.bg-gradient-to-r');
                            existingHints.forEach(h => h.remove());
                            
                            inputElement.parentElement.appendChild(hintContainer);
                            
                            // Focus on input field
                            inputElement.focus();
                            inputElement.select();
                            
                            // Set directory name as starting point
                            fullPathValue = directoryHandle.name;
                        } else {
                            // Success! Remove any existing hints
                            const existingHints = inputElement.parentElement.querySelectorAll('.bg-gradient-to-r, .bg-blue-100, .bg-yellow-100');
                            existingHints.forEach(h => h.remove());
                        }
                        
                        inputElement.value = fullPathValue;
                        console.log('selectFolder - final path set to:', fullPathValue);
                        
                        // Save the path to localStorage for autocomplete
                        if (fullPathValue && fullPathValue.length > 3) {
                            try {
                                const savedPaths = JSON.parse(localStorage.getItem('savedPaths') || '[]');
                                if (!savedPaths.includes(fullPathValue)) {
                                    savedPaths.unshift(fullPathValue);
                                    // Keep only last 10 paths
                                    if (savedPaths.length > 10) {
                                        savedPaths.pop();
                                    }
                                    localStorage.setItem('savedPaths', JSON.stringify(savedPaths));
                                    updateDatalist(type, fullPathValue);
                                }
                            } catch (e) {
                                console.log('Could not save path:', e);
                            }
                        }
                    }
                } else {
                    alert('File System Access API –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –≤ –≤–∞—à–µ–º –±—Ä–∞—É–∑–µ—Ä–µ.\n\n–†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Chrome, Edge –∏–ª–∏ –¥—Ä—É–≥–æ–π —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π –±—Ä–∞—É–∑–µ—Ä.\n\n–ò–ª–∏ –≤–≤–µ–¥–∏—Ç–µ –ø—É—Ç—å –≤—Ä—É—á–Ω—É—é –≤ –ø–æ–ª–µ –Ω–∏–∂–µ.');
                }
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('Error selecting folder:', error);
                    alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–±–æ—Ä–µ –ø–∞–ø–∫–∏: ' + error.message);
                }
            }
        }

        // Drag and drop functionality
        function setupDragAndDrop() {
            const grayDropZone = document.getElementById('grayDropZone');
            const whiteDropZone = document.getElementById('whiteDropZone');
            const grayInput = document.getElementById('grayMockupsPath');
            const whiteInput = document.getElementById('whiteMockupsPath');
            const grayFileTree = document.getElementById('grayFileTree');
            const whiteFileTree = document.getElementById('whiteFileTree');
            const grayDropZoneContent = document.getElementById('grayDropZoneContent');
            const whiteDropZoneContent = document.getElementById('whiteDropZoneContent');

            function handleDragOver(e) {
                e.preventDefault();
                e.stopPropagation();
                e.currentTarget.classList.add('border-blue-500', 'bg-blue-50');
            }

            function handleDragLeave(e) {
                e.preventDefault();
                e.stopPropagation();
                e.currentTarget.classList.remove('border-blue-500', 'bg-blue-50');
            }

            async function handleDrop(e, inputElement, fileTreeElement, dropZoneContent) {
                e.preventDefault();
                e.stopPropagation();
                e.currentTarget.classList.remove('border-blue-500', 'bg-blue-50');

                const files = Array.from(e.dataTransfer.files);
                
                if (files.length === 0) {
                    // Try legacy method with DataTransferItemList
                    const items = e.dataTransfer.items;
                    if (items && items.length > 0) {
                        const item = items[0];
                        if (item.kind === 'file') {
                            const entry = item.webkitGetAsEntry();
                            if (entry && entry.isDirectory) {
                                // Try to read directory recursively
                                const dirFiles = [];
                                async function readDir(dirEntry, path = '') {
                                    const reader = dirEntry.createReader();
                                    const entries = await new Promise((resolve) => {
                                        reader.readEntries(resolve);
                                    });
                                    
                                    for (let entry of entries) {
                                        const entryPath = path ? `${path}/${entry.name}` : entry.name;
                                        if (entry.isFile) {
                                            const file = await new Promise((resolve) => {
                                                entry.file(resolve);
                                            });
                                            file.webkitRelativePath = entryPath;
                                            dirFiles.push(file);
                                        } else if (entry.isDirectory) {
                                            await readDir(entry, entryPath);
                                        }
                                    }
                                }
                                
                                await readDir(entry);
                                
                                if (dirFiles.length > 0) {
                                    files.push(...dirFiles);
                                } else {
                                    inputElement.value = entry.fullPath || entry.name;
                                    return;
                                }
                            } else if (entry && entry.isFile) {
                                const file = await new Promise((resolve) => {
                                    entry.file(resolve);
                                });
                                files.push(file);
                            }
                        }
                    }
                    
                    if (files.length === 0) {
                        return;
                    }
                }

                // Check if files have webkitRelativePath (indicates folder drop)
                const hasRelativePaths = files.some(f => f.webkitRelativePath);
                
                if (hasRelativePaths) {
                    // Build file tree
                    const { tree, rootPath } = buildFileTree(files);
                    
                    // Render tree
                    const treeHtml = renderFileTree(tree, fileTreeElement);
                    fileTreeElement.innerHTML = treeHtml;
                    fileTreeElement.classList.remove('hidden');
                    dropZoneContent.classList.add('hidden');
                    
                    // Try to get full path - improved method
                    let fullPath = '';
                    
                    // Debug: log file information
                    console.log('=== DROP EVENT DEBUG ===');
                    console.log('Files dropped:', files.length);
                    if (files[0]) {
                        console.log('First file object:', files[0]);
                        console.log('First file path:', files[0].path);
                        console.log('First file webkitPath:', files[0].webkitPath);
                        console.log('First file mozFullPath:', files[0].mozFullPath);
                        console.log('First file webkitRelativePath:', files[0].webkitRelativePath);
                        console.log('First file name:', files[0].name);
                        console.log('All file properties:', Object.keys(files[0]));
                    }
                    console.log('Root path from buildFileTree:', rootPath);
                    
                    // Method 1: Try extractFullPath function
                    fullPath = extractFullPath(files);
                    console.log('Extracted path (method 1):', fullPath);
                    
                    // Method 2: Direct extraction from file.path if available - SIMPLIFIED
                    if (!fullPath || fullPath === rootPath || fullPath.length < 3) {
                        const firstFile = files[0];
                        
                        // Check if path property exists and get it
                        let filePath = null;
                        if (firstFile.path) {
                            filePath = firstFile.path;
                        } else if (firstFile.webkitPath) {
                            filePath = firstFile.webkitPath;
                        } else if (firstFile.mozFullPath) {
                            filePath = firstFile.mozFullPath;
                        }
                        
                        if (filePath && firstFile.webkitRelativePath) {
                            // Handle file:// URL format
                            if (filePath.startsWith('file://')) {
                                filePath = decodeURIComponent(filePath.replace('file://', ''));
                            }
                            
                            // We have both full path and relative path - calculate root DIRECTLY
                            const fullFilePath = filePath;
                            const relativePath = firstFile.webkitRelativePath;
                            
                            // Ensure paths are normalized
                            const fullPathNormalized = fullFilePath.replace(/\\/g, '/');
                            const relativePathNormalized = relativePath.replace(/\\/g, '/');
                            
                            // Remove filename from both
                            const fullDirPath = fullPathNormalized.substring(0, fullPathNormalized.lastIndexOf('/'));
                            const relativeDirPath = relativePathNormalized.substring(0, relativePathNormalized.lastIndexOf('/'));
                            
                            // Count directory depth in relative path
                            const relativeDepth = relativeDirPath.split('/').filter(p => p && p !== '.').length;
                            
                            // Split full directory path
                            let fullDirParts = fullDirPath.split('/').filter(p => p && p !== '.');
                            
                            // Ensure we start with / if it's an absolute path
                            if (fullDirPath.startsWith('/')) {
                                fullDirParts = ['', ...fullDirParts];
                            }
                            
                            // Go up relativeDepth levels
                            if (fullDirParts.length > relativeDepth) {
                                const rootParts = fullDirParts.slice(0, fullDirParts.length - relativeDepth);
                                fullPath = rootParts.join('/') || '/';
                                if (!fullPath.startsWith('/') && rootParts[0] !== '') {
                                    fullPath = '/' + fullPath;
                                }
                                console.log('Extracted path (method 2):', fullPath);
                            }
                            
                            // If still not good, try matching by root folder name
                            if (!fullPath || fullPath.length < 3 || fullPath === '/') {
                                const rootFolderName = relativePathNormalized.split('/')[0];
                                const rootIndex = fullDirParts.lastIndexOf(rootFolderName);
                                if (rootIndex !== -1) {
                                    const rootParts = fullDirParts.slice(0, rootIndex + 1);
                                    fullPath = rootParts.join('/') || '/';
                                    if (!fullPath.startsWith('/') && rootParts[0] !== '') {
                                        fullPath = '/' + fullPath;
                                    }
                                    console.log('Extracted path (method 2b):', fullPath);
                                }
                            }
                        } else if (filePath) {
                            // Only have path, extract directory
                            let pathNormalized = filePath;
                            if (pathNormalized.startsWith('file://')) {
                                pathNormalized = decodeURIComponent(pathNormalized.replace('file://', ''));
                            }
                            pathNormalized = pathNormalized.replace(/\\/g, '/');
                            const pathParts = pathNormalized.split('/').filter(p => p && p !== '.');
                            pathParts.pop(); // Remove filename
                            
                            if (pathParts.length > 0) {
                                fullPath = '/' + pathParts.join('/');
                                console.log('Extracted path (method 2c):', fullPath);
                            }
                        }
                    }
                    
                    // Method 3: Try to get from entry.fullPath if available (from webkitGetAsEntry)
                    if ((!fullPath || fullPath === rootPath || fullPath.length < 3) && e.dataTransfer.items) {
                        const items = Array.from(e.dataTransfer.items);
                        for (let item of items) {
                            if (item.kind === 'file') {
                                try {
                                    const entry = item.webkitGetAsEntry();
                                    if (entry) {
                                        // Try fullPath property
                                        if (entry.fullPath && entry.fullPath.startsWith('/')) {
                                            // If it's a directory, use it directly
                                            if (entry.isDirectory) {
                                                fullPath = entry.fullPath;
                                                console.log('Extracted path (method 3a):', fullPath);
                                                break;
                                            } else {
                                                // If it's a file, get parent directory
                                                const pathParts = entry.fullPath.split('/');
                                                pathParts.pop();
                                                fullPath = pathParts.join('/') || '/';
                                                console.log('Extracted path (method 3b):', fullPath);
                                                break;
                                            }
                                        }
                                        
                                        // Try to get path from entry's filesystem
                                        if (entry.filesystem && entry.filesystem.root) {
                                            // This is more complex and may not work in all browsers
                                            console.log('Entry filesystem available');
                                        }
                                    }
                                } catch (err) {
                                    console.log('Error accessing entry:', err);
                                }
                            }
                        }
                    }
                    
                    // Method 4: Try multiple files to find common base
                    if ((!fullPath || fullPath === rootPath || fullPath.length < 3) && files.length > 1) {
                        const pathsWithFullPath = files.filter(f => f.path && f.webkitRelativePath);
                        if (pathsWithFullPath.length > 0) {
                            // Try to find common base path
                            let commonParts = null;
                            for (let file of pathsWithFullPath) {
                                const filePath = file.path;
                                const relativePath = file.webkitRelativePath;
                                const relativeDepth = relativePath.split('/').length - 1;
                                const pathParts = filePath.split('/');
                                
                                if (pathParts.length > relativeDepth) {
                                    const baseParts = pathParts.slice(0, pathParts.length - relativeDepth);
                                    if (!commonParts) {
                                        commonParts = baseParts;
                                    } else {
                                        // Find common prefix
                                        const newCommonParts = [];
                                        for (let i = 0; i < Math.min(commonParts.length, baseParts.length); i++) {
                                            if (commonParts[i] === baseParts[i]) {
                                                newCommonParts.push(commonParts[i]);
                                            } else {
                                                break;
                                            }
                                        }
                                        commonParts = newCommonParts;
                                    }
                                }
                            }
                            
                            if (commonParts && commonParts.length > 0) {
                                fullPath = commonParts.join('/');
                            }
                        }
                    }
                    
                    // Fallback: use root folder name if nothing else works
                    if (!fullPath || fullPath === rootPath || fullPath.length < 3) {
                        fullPath = rootPath || (files[0].webkitRelativePath ? files[0].webkitRelativePath.split('/')[0] : '');
                        
                        // If we only got folder name, show warning
                        if (fullPath && fullPath.length < 10 && !fullPath.startsWith('/')) {
                            console.warn('Could not extract full path. Browser security restrictions may prevent access to full file paths.');
                            console.warn('Please use the "–í—ã–±—Ä–∞—Ç—å –ø–∞–ø–∫—É" button or enter the path manually.');
                            
                            // Show a visual hint
                            const hint = document.createElement('div');
                            hint.className = 'mt-2 p-2 bg-yellow-100 border border-yellow-400 text-yellow-700 rounded text-xs';
                            hint.innerHTML = '‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø–æ–ª–Ω—ã–π –ø—É—Ç—å. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫—É "–í—ã–±—Ä–∞—Ç—å –ø–∞–ø–∫—É" –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ –ø—É—Ç—å –≤—Ä—É—á–Ω—É—é.';
                            inputElement.parentElement.appendChild(hint);
                            
                            // Remove hint after 5 seconds
                            setTimeout(() => {
                                if (hint.parentElement) {
                                    hint.parentElement.removeChild(hint);
                                }
                            }, 5000);
                        }
                    }
                    
                    // Update input with full path
                    if (fullPath) {
                        inputElement.value = fullPath;
                        console.log('Final path set to:', fullPath);
                    }
                } else {
                    // Single file or no relative paths
                    const firstFile = files[0];
                    if (firstFile.path) {
                        const pathParts = firstFile.path.split('/');
                        pathParts.pop();
                        inputElement.value = pathParts.join('/');
                    } else {
                        inputElement.value = firstFile.name;
                    }
                }
            }

            grayDropZone.addEventListener('dragover', handleDragOver);
            grayDropZone.addEventListener('dragleave', handleDragLeave);
            grayDropZone.addEventListener('drop', (e) => handleDrop(e, grayInput, grayFileTree, grayDropZoneContent));

            whiteDropZone.addEventListener('dragover', handleDragOver);
            whiteDropZone.addEventListener('dragleave', handleDragLeave);
            whiteDropZone.addEventListener('drop', (e) => handleDrop(e, whiteInput, whiteFileTree, whiteDropZoneContent));
        }

        // Load saved paths into datalist for autocomplete
        function loadSavedPaths() {
            try {
                const savedPaths = JSON.parse(localStorage.getItem('savedPaths') || '[]');
                
                const grayDatalist = document.getElementById('grayMockupsPathSuggestions');
                const whiteDatalist = document.getElementById('whiteMockupsPathSuggestions');
                
                // Filter paths for gray and white
                const grayPaths = savedPaths.filter(p => p.includes('gray') || p.includes('Gray'));
                const whitePaths = savedPaths.filter(p => p.includes('white') || p.includes('White'));
                
                // Add all paths if no specific matches
                if (grayPaths.length === 0) grayPaths.push(...savedPaths);
                if (whitePaths.length === 0) whitePaths.push(...savedPaths);
                
                // Populate datalists
                grayPaths.forEach(path => {
                    const option = document.createElement('option');
                    option.value = path;
                    grayDatalist.appendChild(option);
                });
                
                whitePaths.forEach(path => {
                    const option = document.createElement('option');
                    option.value = path;
                    whiteDatalist.appendChild(option);
                });
            } catch (e) {
                console.log('Could not load saved paths:', e);
            }
        }

        // Update datalist when path is saved
        function updateDatalist(type, newPath) {
            try {
                const datalistId = type === 'gray' ? 'grayMockupsPathSuggestions' : 'whiteMockupsPathSuggestions';
                const datalist = document.getElementById(datalistId);
                
                // Check if option already exists
                const exists = Array.from(datalist.options).some(opt => opt.value === newPath);
                if (!exists) {
                    const option = document.createElement('option');
                    option.value = newPath;
                    datalist.insertBefore(option, datalist.firstChild);
                    
                    // Keep only last 10 options
                    while (datalist.options.length > 10) {
                        datalist.removeChild(datalist.lastChild);
                    }
                }
            } catch (e) {
                console.log('Could not update datalist:', e);
            }
        }

        // Improve drag-and-drop message
        function improveDropZoneMessage(dropZone, type) {
            const dropZoneContent = dropZone.querySelector(`#${type}DropZoneContent`);
            if (dropZoneContent) {
                const originalText = dropZoneContent.querySelector('p.text-sm');
                if (originalText) {
                    originalText.innerHTML = `
                        –ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –ø–∞–ø–∫—É —Å ${type === 'gray' ? '—Å–µ—Ä—ã–º–∏' : '–±–µ–ª—ã–º–∏'} —Å–∫—Ä–∏–Ω—à–æ—Ç–∞–º–∏ —Å—é–¥–∞
                        <br><span class="text-xs text-gray-500 mt-1 block">üí° –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–Ω–æ–ø–∫—É "–í—ã–±—Ä–∞—Ç—å –ø–∞–ø–∫—É" –Ω–∏–∂–µ –¥–ª—è –ª—É—á—à–µ–π —Ä–∞–±–æ—Ç—ã</span>
                    `;
                }
            }
        }

        // Save path when user manually enters it
        function setupPathInputHandlers() {
            const grayInput = document.getElementById('grayMockupsPath');
            const whiteInput = document.getElementById('whiteMockupsPath');
            
            function savePathOnBlur(input, type) {
                input.addEventListener('blur', function() {
                    const path = this.value.trim();
                    if (path && path.length > 3 && path.startsWith('/')) {
                        try {
                            const savedPaths = JSON.parse(localStorage.getItem('savedPaths') || '[]');
                            if (!savedPaths.includes(path)) {
                                savedPaths.unshift(path);
                                if (savedPaths.length > 10) {
                                    savedPaths.pop();
                                }
                                localStorage.setItem('savedPaths', JSON.stringify(savedPaths));
                                updateDatalist(type, path);
                            }
                        } catch (e) {
                            console.log('Could not save path:', e);
                        }
                    }
                });
            }
            
            if (grayInput) savePathOnBlur(grayInput, 'gray');
            if (whiteInput) savePathOnBlur(whiteInput, 'white');
        }

        // Initialize drag and drop on page load
        document.addEventListener('DOMContentLoaded', () => {
            setupDragAndDrop();
            loadSavedPaths();
            setupPathInputHandlers();
            
            // Improve drop zone messages
            const grayDropZone = document.getElementById('grayDropZone');
            const whiteDropZone = document.getElementById('whiteDropZone');
            if (grayDropZone) improveDropZoneMessage(grayDropZone, 'gray');
            if (whiteDropZone) improveDropZoneMessage(whiteDropZone, 'white');
        });
    </script>
</body>
</html>
